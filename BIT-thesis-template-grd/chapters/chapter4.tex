%%==================================================
%% chapter04.tex for BIT Master Thesis
%%==================================================
\chapter{系统的工具和算法原理}
本章详细介绍系统的工具、功能、算法开发工作和原理。1段

本章对调度系统的区块链服务端和用户端涉及到的算法和工具进行了详细的介绍。服务器端主要涉及地理信息的存储和基于地理信息的算法工作，包括GeoHash静态矢量地图的存储，基于GeoHash静态矢量地图的路径规划算法，筛选最近的空车来与乘客进行匹配的车乘匹配算法。在车辆和乘客的用户端，主要是基于leaflet工具进行GeoHash矢量地图的展示，以及添加相应的功能来优化展示效果。

张禹：14页
1段
4.1 低采样率下的服务器端路况挖掘1段
4.1.1近似算法（一图）5-6段
4.1.2在线道路匹配算法（三图）6段
4.1.3路口模型描述3段
4.1.4路况计算（一图四公式）6段
4.1.5缺失路况的补充（一公式）4段

4.2
3段
4.2.1基于GeoHash的地图存储4段
4.2.2网页端路况挖掘（两图）6段
4.2.3不足与改进方向（一图展示页面）6段
4.3小结1段

共47段

\section{基于GeoHash的矢量地图展示}
对系统开发过程中将基于GeoHash的矢量地图信息存储在区块链和展示在浏览器端的开发工作和原理做介绍。1段

由于终端通信设备的普及和迭代，自组网系统的应用规模不断增大，基于中心化服务器的业务处理速度无法满足网络请求响应的实时性，也限制了自组网车辆之间的通信。而利用区块链的特性实现的分布式后台，既可以保证交易记录的安全性，防止恶意攻击者对地理信息和位置信息、交易信息的篡改，还可以方便成员之间的相互通信，同时其分布式的特性也能够满足对大规模网络请求的及时响应。

本节将介绍GeoHash矢量地图在区块链中的存储逻辑，同时还会介绍在终端页面实现的对GeoHash矢量地图的渲染逻辑，以及为了优化地图展示效果补充的放缩和拖动功能的实现逻辑。

\subsection{基于GeoHash的地图在区块链上的存储}
将矢量地图数据以GeoHash形式存到区块链上的原理、优点分析和改进空间。6段

GeoHash是一种新型的地址编码方式，由Gustavo Niemeyer和G.M. Morton发明[董斌37]，其具体算法是二分法结合编码的一种地理位置信息算法[董斌16]，被广泛应用到地理位置表示中。最开始，以本初子午线、赤道为界，地球可以分为 4 个部分，设定西经为负，南纬为负，所以地球上的经度范围就是 [-180,180]，纬度范围就是 [-90,90]。GeoHash 使用了Peano空间填充曲线（一张图），在处理地图数据的过程中，要将经纬度点转换成GeoHash，首先要通过二分的方法把经纬度转化成二进制编码，以 (116.3639092,39.9662639) 为例，将其转化为精度为8位的GeoHash，过程如下表3-1所示。将经度和纬度分别转换成一组二进制字符串，然后将经度和纬度的二进制字符串以位置交叉的形式进行组码，生成一组新的更长的二进制字符串，新的二进制字符串中偶数位的数字对应原来的经度二进制串，奇数位的数字对应原来的纬度二进制串，然后将新字符串每五位一组转为十进制数字，并根据数字找到其在Base32(即数字 0-9 和字母 b-z 不包括 a,i,l,o 的 32 个字符) 数组的映射，以此进行编码[董斌16]，最终实现用GeoHash一维数据表示原经纬度二维数据的效果。（一张表用来示例）

根据Geohash特殊的编码方式，一个GeoHash值对应一个近似矩形的覆盖区域，当位数较短时，它可以表示一块区域的坐标，当位数足够长时，它可以表示地球上某个具体点的坐标，重要的一点是，GeoHash位数短的区域一定包含以这个GeoHash为前缀的所有地图数据（一张图示例），这一特点对地图数据进行区域绑定提供了极大的便利。GeoHash在编码过程中保留了一定的相对地理位置信息，在大部分情况下，GeoHash编码共同前缀越长的区块物理距离越近[董斌37]，一个6位GeoHash块的覆盖区域大小为1220m*1220m。
传统的地图数据采用经纬度的方法进行存储，不方便实现位置与区域绑定，并且二维数据存储内容较大，对网络环境和存储设备的要求较高。采用 GeoHash 字符串存储地图信息可以使所有信息平面化，更方便区域信息绑定，并且一维字符串降低了存储数据的规模，同时基于GeoHash地理信息的运算复杂度较低，也更适用于 Solidity 语言。同时，根据 GeoHash 编码规则，一个 GeoHash 值所代表的区域一定包含以该 GeoHash 值为前缀的所有元素。

车辆和乘客的终端在使用时需要从区块链中读取地图信息。为了降低地图数据对终端设备的内存要求，以及降低对网络资源的占用，在区块链存储地图时可将地图进行分块处理，这样终端不用一次读入所有的地图信息。同时，分块后的道路会按照其GeoHash位置的前缀绑定到相应的GeoHash区域内，这样终端在获取地图时能够根据用户的GeoHash位置读入该GeoHash所属的大范围GeoHash区域的地图信息，而不用遍历所有的地图数据，在提高获取效率的同时还会减少网页端的内存消耗，也便于终端地图信息的更新。（一张区域绑定示意图）

智能合约中存储的道路信息包括道路ID、道路起点位置、终点位置、道路路径上的点构成的数组（道路为折线段结构）、标识道路间连接信息的 ID（每条道路只在首尾处与其他道路相接）、道路名、道路长度以及单双向行驶标识。道路信息属于静态数据，在存储到地图合约的过程中，会对道路末尾连接处所能到达的所有道路的信息记录成一个数组映射，以方便路径规划算法在运行时对下一条可达道路的启发式查找。另外，由于开发语言不支持浮点数，因此距离信息需要用GeoHash距离运算的整数结果来表示，此处需要调整运算过程中的参数来找到准确度和运算效率双优的参数。（一张表）

\subsection{基于GeoHash的矢量地图的终端数据显示}
画一个流程图，按流程图描述（一图）
1.计算当前层级GeoHashTile的size
2.计算当前屏幕内GeoHashTile的个数（一共5个公式）
3.计算当前屏幕内所有GeoHashTile的编码（简单提及）
4.向服务端请求地图数据（简单提合并的过程）
5.压缩数据，计算GeoHashTile的中心GeoHash（简单提）
6.计算像素距离（简单提及）
7.计算地图对象的屏幕坐标（1个公式）
8.将tile pixel distance和coordinate pixel distance做缓存（简单提及）

[周畅]的GeoHashTile工作设计了基于GeoHash体系的矢量地理数据结构——GeoHashTile，利用了GeoHash对矢量地理数据的高效分区和一维索引，方便对地理数据的查询，并且其支持了对GeoHash地理信息的显示，实现了GeoHash坐标和屏幕上像素坐标的直接转换，并且验证了GeoHashTile在请求数据的速度上比基于经纬度的GeoTile系统有明显优势。其GeoHash转换成屏幕坐标采用的是相对投影的方法。

终端完成显示Geohash矢量地理数据的过程，如图5所示，主要包括三个部分：
（1）计算GeohashTile的数量和编码，包括三个步骤：首先获得当前缩放级别下一块GeohashTile的像素大小（每个级别的瓦片像素大小已经通过推理计算设置好[周畅论文]），然后通过屏幕的长宽像素计算客户端中GeohashTile的数量，得到数量后，再通过中心瓦片的GeoHash编码和查找邻居瓦片的算法，计算终端屏幕中所有GeohashTile的编码。
（2）地图数据请求发送到服务端之前，为了减少请求报文的规模，使用GeohashTile请求合并算法来实现要发送的请求的合并。服务器收到请求后会查找请求的所有区域的数据，并整理成基于GeoHash的GeoJSON数据返回给终端。
（3）终端收到地图数据后会进行投影显示，相对位置投影过程包括数据压缩、计算像素距离和计算屏幕坐标三个步骤。实现投影的第一步是计算从这些目标点到中心点的相对像素距离列表。有两种相对距离计算（如图5中的步骤6所示）。第一个是计算从各个GeohashTile中心像素点到屏幕中心像素点的相对像素距离。第二个是计算从目标点的像素点到其所属GeohashTile中心像素点的相对像素距离。将这二者相加即可得到目标点的在屏幕中的像素位置，通过画点接口进行投影。

GeohashTile的计算过程是根据给定的中心位置center_geohash、缩放级别z和客户端clientSize的屏幕大小，计算屏幕范围内覆盖的GeohashTile数量和相应编码长度GeohashTile序列的过程。

4.1.1. 计算一块GeohashTile的大小，如步骤1所示？如图5所示。在瓦片地图系统中，瓦片的索引遵循四叉树原则。在每个缩放级别，等式（2）用于计算在x轴和y轴方向上的瓦片数量，其中z是缩放级别。
公式(2)
Geohash编码的每多一个字符就代表将一块区域进行更深层的子分区，一个区域根据编码的奇偶字节交替划分为4×8或8×4子区域。每次分区后对应的x轴和y轴方向上的GeohashTile编码数量的计算公式为公式（3），其中l是Geohash编码的长度。 
公式(3)
GeoHashTile的缩放级别z与GeoHash的字符长度l并不是严格相关的。由于GeoHash每一层的分区都多于GeoTile系统中的四叉树分区，因此，我们结合方程（2）和（3）得到Geohash编码长度l和缩放级别z之间关系的方程（4），在满足公式(4)的基础上，使用最短长度的Geohash编码来做瓦片，以减少存储。对于每个层级z，l的计算结果取最小整数。
公式(4)
无论谷歌地图、必应地图或其他地理信息显示系统如何，每层的分幅都是固定的像素大小（最常见的分幅像素大小为256×256）。从上面可以看出，Geohash每一层的瓦片大小都是相同的，并且层与层之间的瓦片大小根据划分规则有规律地变化。由于x和y方向的分割大小不一致，Geohash瓦片大多为矩形。为了使GeohashTile在每个级别上近似于256×256的平方像素大小，并便于计算，GeohashTile的像素大小在缩放级别0设置为512×512。结合方程式（4）的计算结果，可通过方程式（5）计算相应缩放级别z下的GeohashTile大小。在等式（5）中，z是缩放级别，l是Geohash编码长度。由于Geohash在x和y方向上的除法规则不一致，因此需要两个不同的方程来完成计算。 
公式(5)
表3显示了通过等式（5）计算的GeohashTile的像素大小，其中缩放级别为1–18。除了能够计算具有不同编码长度的GeohashTile的像素大小之外，等式（5）还用于稍后计算Geohash坐标点转换屏幕像素坐标。
表3
4.1.2. 计算客户端中GeohashTile的数量在获得相应缩放级别中GeohashTile的大小后，可以通过组合客户端像素大小来计算屏幕中覆盖的GeohashTile的数量，以便为从服务器获取相应的地图数据做准备（如图5中的步骤2所示）。方程式（6）是计算地砖坐标x轴和Y轴方向上的GeohashTile编码数量的方程式，其中大小为。x、 尺寸。y是客户端屏幕的像素大小。
公式(6)
为了确保GeohashTile覆盖屏幕，计算结果将被四舍五入。这也是图5所示GeohashTile覆盖范围超出屏幕的原因。

4.1.3. 计算客户端中的所有GeohashTile编码以从服务器获得相应的地图数据，我们应该计算屏幕覆盖范围中的所有GeohashTile编码（如图5中的步骤3所示）。

4.3 相对位置投影处理所有地图数据都需要从球面数据投影到二维平面数据进行显示。本节描述的Geohash地图数据的相对位置投影过程是使用相对位置计算方法将Geohash编码的地图数据直接投影到屏幕坐标的过程。具体计算步骤如下：

4.3.1. 编码长度和缩放级别的关系
公式(7)
公式(8)
这里我们有两个定义来帮助解释。
定义1
定义2
公式(9)
4.3.2. 计算相对像素距离
算法3

4.3.3. 客户端屏幕中心点像素+tile中心点像素偏移+coord相对tile中心点的偏移

\subsection{基于GeoHash的矢量地图实现放缩和拖动功能}

上一节主要讨论了GeoHash矢量地理数据在终端的的投影过程，其核心工作是将GeoHash字符串转投影为屏幕上的像素坐标。本节讲述实现放缩和拖动功能的原理工作，其核心部分的实现逻辑与上一节所述内容相反，实现放缩和拖动功能需要重新设置地图视野的中心点GeoHash，这需要将鼠标在屏幕上的像素点位置转化成相对应地图图层的GeoHash地理位置。（逻辑流程图）

实现GeoHashTile的拖动功能，即通过监听终端操作获得给定的像素值变化，然后对地图进行平移；实现放缩功能，即通过监听终端操作获得缩放等级的变化，然后将地图展示成新的缩放等级。放缩或者拖动结束之后，需要重新获取视野的中心点GeoHash字符串，这个工作是将变化后的地图图层的中心点投影成GeoHash字符串，需要实现将屏幕的像素坐标投影成GeoHash字符串的功能。

首先遍历屏幕内的所有GeoHashTile瓦片，通过（算法）根据每个瓦片的范围判断操作点所在的瓦片，然后获得该瓦片的中心点GeoHash和中心点像素位置，通过操作点的像素位置和操作点所在的GeoHashTile的像素位置，可以通过（公式1）计算出两点之间的相对像素差，根据相对像素差，结合本缩放层级下的瓦片像素大小，可以通过（公式2）计算出操作点和瓦片中心点在该精度下的GeoHash在东西和南北方向上的地理偏移量（以瓦片中心点GeoHash的精度下所对应的GeoHash格子数表示），根据操作点相对于瓦片中心点的GeoHash地理偏移量，可以通过（算法1）计算出操作点的GeoHash，此GeoHash的精度与瓦片中心点GeoHash相同。（放大缩小示意图）

7086_onDragEnd->map.panBy(offset)将地图按给定像素平移

\section{基于GeoHash的几何计算优化}3段
由于传统计算两个经纬度所表示坐标点距离时需要使用球面距离公式，若在以 GeoHash 为坐标表示的系统中沿用这套算法，则丧失了 GeoHash 带来的计算简便性。利用GeoHash编码的特点进行距离计算，避免了复杂的三角函数和球面计算，并且适用于对小数支持较弱、不提供复杂数学函数计算支持的区块链智能合约编写语言 Solidity。

\subsection{GeoHash几何计算原理}
具体介绍GeoHash数格子进行几何距离计算的原理。

在将经纬度编码为GeoHash时，首先要将经纬度分别通过二分法编码为对应长度的二进制编码，然后将经度和纬度的二进制编码按照偶数位放经度的二进制编码、奇数位放维度的二进制码的方式进行组码，最后将新获得的组码串进行Base32编码，即可获得GeoHash字符串。

在上述编码的过程中，经纬度二分后对应的两个二进制编码，其对应的十进制值也有特殊的地理意义：即在当前要编码的GeoHash精度下，这一对经纬度对应的GeoHash瓦片，相对于赤道原点处所偏移的相同规模的GeoHash瓦片的数量。经度对应的二进制编码的十进制值表示在东西方向上偏移的瓦片数量，纬度对应的二进制编码的十进制值表示在南北方向上偏移的瓦片数量。

根据上述原理，在计算两个GeoHash位置之间的距离时，可以先将两个GeoHash各自解码为在东西和南北方向上表示偏移的数值，再计算这两者在东西和南北方向上偏移的数值之差，即可得到两点之间在东西和南北方向上的相对位置差。由于经纬度划分的原因，在一定的GeoHash精度下，所有瓦片的南北距离都是相同的，但东西距离会根据GeoHash点所在纬度的增加而减小。在10位GeoHash精度下，每个瓦片的东西宽度，可以按纬度的不同大致划分为16个区域。故两个GeoHash点之间的南北距离可以根据南北瓦片的偏差值乘以当前GeoHash精度下瓦片的南北距离（单位：米）获得；而两个GeoHash点之间的东西距离需要根据GeoHash所属的纬度区域找到GeoHash瓦片的东西距离（单位：米），再乘以两者的东西瓦片偏差值获得。

\subsection{GeoHash几何计算方法的优化}
在实际的出租车系统应用环境中，两个终端之间的距离计算所涉及到的地区范围，通常情况下不会超过市辖区以上的规模。故在出租车系统的环境下，两个终端的地理位置GeoHash会有一定位数的前缀是相同的（通常在5位到6位，画一个GeoHash规模对应格子大小的表格）。据此，这两个GeoHash解码后的二进制偏移值的前几位也会相同。事实上二者相同前缀所转化的高位数字是相同的，做减法之后会相互抵消。这些相同前缀转化的的高位数字对二者相对偏移的计算没有影响，这就造成了在GeoHash解码时对计算资源的浪费。

在地理视角上，计算两个GeoHash之间的距离，首先是对GeoHash进行解码计算出二者相对赤道原点的偏移，如果计算时不考虑两个GeoHash前缀相同的部分，此处的参照对象就会从赤道原点改为同时包含这两个GeoHash瓦片前缀瓦片（即二者相同前缀部分的GeoHash所表示的瓦片）原点，以距离二者更近的原点作为参照，可以减少计算瓦片偏移数量时的运算规模，从而加快运算速度，使距离计算的算法性能得到提升。（优化示意图）

本文在进行GeoHash距离计算时，首先检查两个GeoHash的前缀相同的部分，然后取其不同的部分进行距离计算，以优化距离计算的性能，利用了GeoHash字符串的特性，加快系统的响应速度。算法的逻辑如下（算法），具体的性能优化效果在第五章进行描述。



\section{基于GeoHash的路径规划算法}
为了完善去中心化的出租车调度系统，需要在智能合约端实现后台的路径规划算法。路径规划算法需要根据智能合约上存储的GeoHash矢量地图数据进行静态导航，参考GeoHash地图存储的格式，在进行地图存储时根据路口的连接关系建立路口之间的拓扑连接关系。本节采用优化后的GeoHash距离计算方法，结合常规静态路网规划算法A*算法，提出了基于GeoHash矢量地图的路径规划算法，为车辆提供路径规划服务。本节实现的路径规划算法可以根据不同的道路权值类型进行路径规划，还可以调节算法参数，在保证路径规划准确性的前提下提高效率。同时，为避免不必要的服务纠纷，会对路径规划的结果进行记录。

路径规划算法的提出和发展由来已久，有适合在未知地图环境下运行的启发式路径规划算法，可以应用在智能机器人和无人车等领域，此外，还有可以在已知地图信息的情况下，利用已有的矢量地图数据规划出最短路径的路径规划算法，可以应用在地理信息实时更新的交通系统中。传统的路径规划算法，是在已知地理信息的情况下进行最短路径的规划，可以应用在车载应用的路径规划、公共交通实时路径规划等环境中。启发式路径规划算法，适合在不知道地理信息的情况下进行主观的路径探索，这种算法应用在机器人的自动寻路、游戏中的AI角色寻路等场景；本文所描述的系统已有静态矢量地图拓扑信息的支持，故采用静态路网的路径规划算法为车辆提供路径规划的辅助。

\subsection{矢量地图路径路径规划算法的性能对比}

Dijkstra算法是由E.W.Dijkstra于1959年提出，属于贪心算法模式，是非常典型的最短路径算法。此算法可以用于求得移动机器人行进路线中的一个节点到其他所有节点的最短路径。算法的主要特点是：以输入的起始点为中心，算法过程中生成无向图一直向外扩展，直到扩展到最终的目标点为止，通过节点和权值边的连接关系来构成整个路径。Dijkstra算法的缺点是效率低，在无向图扩展的过程中会生成大量的无效路径，占用较多的内存空间。

A*算法（Dijkstra with a Heuristic）是在Dijksra的基础上加入启发式函数实现的，因为加入启发算子的缘故，在拓展无向图的过程中可以根据目标点相对中间点的距离协调选择最好的方向进行搜索。相比Dijkstra算法的效率更高，占用内存空间更少。A*算法的应用范围比较广，可以在电子地图进行路径规划，或者在游戏领域中应用于虚拟角色的行走路径的规划，A*算法的计算结果正确性较高，能够调整算子来适应不同的路径权值类型，拓展了其健壮性和适用范围。

JPS算法在A*算法框架的基础上加入了跳点搜索（Jump Point Search），JPS会根据当前点的方向及当前点周围邻居的特点进行选择，某些特殊的点才能执行加入和删除到可探索点集合的操作。在网格地图中，JPS算法可以用来提高有障碍物时的寻路效率，在遇到障碍物时需要改变搜索方向，这时只把能够以最短路径避过障碍的跳跃点加入可探索点集合中，可以避免考虑很多不必要的路径点，以此来提高算法的搜索效率。但本文的静态地图在储存时已经生成邻居道路的拓扑结构，不需要考虑避开障碍物。JPS算法在已有拓扑结构的地图中徒增算法的复杂度，故不在本文应用。

CH算法在A*算法的基础上加入了预处理的过程，算法在预处理阶段创建“shortcuts”来实现提速，然后在最短路径查询中使用这些“shortcuts”来跳过“不重要的”顶点。“shortcuts”可用于保存两个重要路口之间预先计算的距离，从而算法无需在查询时考虑这些路口之间的完整路径，这样可以使查询路径缩短，查询效率得到提高。但CH算法的预处理使得查询时的道路网络失去了真实的拓扑结构，在每一条道路信息更新后都需要重新对全局进行预处理；此外，道路权值类型的更改也会重新触发整个预处理过程，不能很好地支持实时的交通信息，系统的拓展性和健壮性不足。

\subsection{基于GeoHash的A*路径规划算法的原理}
A*算法是一种直接查询算法，只需要地图的拓扑数据，而不需要做任何预处理。同时 A*算法是一个启发式算法，利用了启发函数，A*算法的启发函数算子可以记成 h(n)，代表着算法过程查询到的中间节点到目的地节点的距离估计值。A*算法在选择路径中第n个被检查的节点时，还会参考从起始点到第n个中间节点的实际距离，称为耗散函数，记为 g(n)。A*算法的对中间节点的估计函数（如公式）同时参考了耗散函数和启发函数，将二者的和作为评价该节点处于最优路线上的可能性的量度，这样可以首先搜索可能性大的节点。在算法运行的过程中，A*算法根据评估函数f(n)的值，找到距离终点最近的可能性最大的节点，然后展开搜索该节点，而不用每一步规划都需要搜索所有节点，提高了路径规划的效率。

A*算法的的核心是设置一个合适的评估函数，评估函数的计算方式对搜索结果有决定性作用。对第n个中间节点来说， g(n) 的值基本是固定的，其反映的是从起点到当前节点的实际道路距离。因此，启发函数 h(n)的选择就显得更重要，它能控制 A*算法计算过程中的行为。如果把 h(n)设置为 0，这时候 f(n)=g(n)，A*算法就会退化为 Dijkstra 算法，也能计算出目标路径。启发函数的影响越小，在 A*寻路时需要探索的节点越多，寻路过程就会变慢。启发函数 h(n) 的值如果设置的比 g(n) 大非常多，相当于只有启发函数起作用，A*算法接近 BFS 算法，路径规划的结果不一定是最短路径。
常用的启发函数 h(n)二维坐标下有以下几个距离度量方法：
（1）曼哈顿距离，表示在标准坐标系上的绝对坐标轴距之和，

（2）欧几里得距离，也叫欧式距离，表示两点之间的直线距离。

本文的实验部分基于GeoHash矢量地图数据，道路属性里的cost字段记录的是道路的实际长度，这个长度即是每条路段的两个端点之间的距离，以米为单位。为了简化启发函数的计算，从而支持智能合约语言的特性，本文采用曼哈顿距离作为度量，结合GeoHash计算距离的函数进行启发函数的计算。为了使启发函数 h(n) 的结果与实际情况更接近，本文调整了GeoHash计算距离函数的参数，使启发函数的结果更接近真实的道路距离，这一步可以让路径规划结果的正确性和算法的效率都得到保障。


\section{基于树状区块链的区域调度车乘匹配算法}1段

在

\subsection{树状区块链对区域信息的查询}4-6段
介绍树状区块链对区域信息的查询原理。


\subsection{区域调度车乘匹配算法}3段
介绍在树状区块链对区域信息查询的基础上实现的区域调度车乘匹配算法原理、对并发请求的冲突解决逻辑。



\upcite{2016A}考虑正常交通对出租车的影响，提出了一种出租车调度系统，该系统使用实时交通状况将空置的出租车与最近的（在旅行时间方面）等候的乘客相匹配。